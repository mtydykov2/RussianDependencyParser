.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lingua::RU::OpenCorpora::Tokenizer 3pm"
.TH Lingua::RU::OpenCorpora::Tokenizer 3pm "2011-09-28" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Lingua::RU::OpenCorpora::Tokenizer \- tokenizer for OpenCorpora project
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $tokens = $tokenizer\->tokens($text);
\&
\&    my $bounds = $tokenizer\->tokens_bounds($text);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module tokenizes input texts in Russian language.
.PP
Note that it uses probabilistic algorithm rather than trying to parse the language. It also uses some pre-calculated data freely provided by OpenCorpora project.
.PP
\&\s-1NOTE:\s0 OpenCorpora periodically provides updates for this data. Checkout \f(CW\*(C`opencorpora\-update\-tokenizer\*(C'\fR script that comes with this distribution.
.PP
The algorithm is this:
.IP "1. Split text into chars." 4
.IX Item "1. Split text into chars."
.PD 0
.IP "2. Iterate over the chars from left to right." 4
.IX Item "2. Iterate over the chars from left to right."
.IP "3. For every char get its context (see \s-1CONTEXT\s0)." 4
.IX Item "3. For every char get its context (see CONTEXT)."
.ie n .IP "4. Find probability for the context in vectors file (see ""\s-1VECTORS\s0 \s-1FILE\s0"") or use the default value \- 0.5." 4
.el .IP "4. Find probability for the context in vectors file (see ``\s-1VECTORS\s0 \s-1FILE\s0'') or use the default value \- 0.5." 4
.IX Item "4. Find probability for the context in vectors file (see VECTORS FILE) or use the default value - 0.5."
.PD
.SS "\s-1CONTEXT\s0"
.IX Subsection "CONTEXT"
In terms of this module context is just a binary vector, currently consisting of 17 elements. It's calculated for every character of the text, then it gets converted to decimal representation and then it's checked against \*(L"\s-1VECTORS\s0 \s-1FILE\s0\*(R". Every element is a result of a simple function like \f(CW\*(C`_is_latin\*(C'\fR, \f(CW\*(C`_is_digit\*(C'\fR, \f(CW\*(C`_is_bracket\*(C'\fR and etc. applied to the input character and few characters around it.
.SS "\s-1VECTORS\s0 \s-1FILE\s0"
.IX Subsection "VECTORS FILE"
Contains a list of vectors with probability values showing the chance that given vector is a token boundary.
.PP
Built by OpenCorpora project from semi-automatically annotated corpus.
.SS "\s-1HYPHENS\s0 \s-1FILE\s0"
.IX Subsection "HYPHENS FILE"
Contains a list of hyphenated Russian words. Used in vectors calculations.
.PP
Built by OpenCorpora project from semi-automatically annotated corpus.
.SS "\s-1EXCEPTIONS\s0 \s-1FILE\s0"
.IX Subsection "EXCEPTIONS FILE"
Contains a list of char sequences that are not subjects to tokenizing.
.PP
Built by OpenCorpora project from semi-automatically annotated corpus.
.SS "\s-1PREFIXES\s0 \s-1FILE\s0"
.IX Subsection "PREFIXES FILE"
Contains a list of common prefixes for decompound words.
.PP
Built by OpenCorpora project from semi-automatically annotated corpus.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Constructs and initializes new tokenizer object.
.ie n .SS "tokens($text [, $options])"
.el .SS "tokens($text [, \f(CW$options\fP])"
.IX Subsection "tokens($text [, $options])"
Takes text as input and splits it into tokens. Returns a reference to an array of tokens.
.PP
You can also pass a hashref with options as a second argument. Current options:
.IP "threshold" 4
.IX Item "threshold"
Minimal probability value for tokens boundary. Boundaries with lower probability are excluded from consideration.
.Sp
Default value is 1, which makes tokenizer do splitting only when it's confident.
.SS "tokens_bounds($text)"
.IX Subsection "tokens_bounds($text)"
Takes text as input and finds bounds of tokens in the text. It doesn't split the text into tokens, it just marks where tokens could be.
.PP
Returns an arrayref of arrayrefs. Inner arrayref consists of two elements: boundary position in text and probability.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Lingua::RU::OpenCorpora::Tokenizer::Updater
.PP
<http://mathlingvo.ru/nlpseminar/archive/s_49>
.SH "AUTHOR"
.IX Header "AUTHOR"
OpenCorpora.org team <http://opencorpora.org>
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software, you can redistribute it under the same terms as Perl itself.
